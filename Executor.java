
import java.io.*;
import java.util.List;
import java.util.Map.Entry;

import principleProject2.ParseTree.*;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;


public class Executor {
	private Executor() {}
	
	//DataFromFile: individual value from data file
	private static List<Integer> DataFromFile = new LinkedList<Integer>();
	//ID: identifiers with their associated value
	private static HashMap<String,Integer> GLOBALID = new HashMap<String,Integer>();
	//INPUTID: identifiers with their associated value
	private static HashMap<String,Integer> INPUTID = new HashMap<String,Integer>();
	//To store function name and the given parameter;
	private static HashMap<String, DECL_FUNC> funcID = new HashMap<>();
	//For storing passed parameter
	private static HashMap<String, Integer> localID = new HashMap<>();
	
	//before passing as param
	private static HashMap<String, Integer> h = new HashMap<>();
	private static boolean hasParam = false;
	private static boolean programBegin = false;
	private static String paramName = "";
	
	//parseTree: tree generated by parser, data: name of the data file
	public static void execute(PROG parseTree, String data) {
		getData(data);
		
		execProg(parseTree);
	}
	
	
	/*============================================================================*/
	public static void execProg(PROG prog) {
		execDeclSeq(prog.getDeclSeq());
		execStmtSeq(prog.getStmtSeq());
	}
	public static void execDeclSeq(DECL_SEQ declSeq) {
		//for declaring global variable
		execDecl(declSeq.getDecl());
		if(declSeq.getNo() == 1) {
			execDeclSeq(declSeq.getDeclSeq());
		}
	}
	public static void execStmtSeq(STMT_SEQ stmtSeq) {
		programBegin = true;
		execStmt(stmtSeq.getStmt());
		if(stmtSeq.getNo() == 1) {
			execStmtSeq(stmtSeq.getStmtSeq());
		}
	}
	public static void execDecl(DECL decl) {
		if(decl.getNo() == 0) {	//decl id
			execDeclId(decl.getDeclId());
		}else if(decl.getNo() == 1) {	//decl func
			//store skeleton of the declared function for later use
			if(!funcID.containsKey(decl.getDeclFunc().getId())) {
				funcID.put(decl.getDeclFunc().getId(), decl.getDeclFunc());
			}
			//execDeclFunc(decl.getDeclFunc().getId());
		}
	}
	public static void execDeclId(DECL_ID declId) { //???Correct?
		//globally accessible ID
		execIdList(declId.getIdList(), GLOBALID);
		
	}
	public static void execDeclFunc(String id) { //???Correct?
		//when a declared function is being called, execute it
		
		//calling function that does not exist
		if(!funcID.containsKey(id)) {
			System.out.println("Error: Func" + id + " does not exist!");
		}
		//begin executing function
		execIdList(funcID.get(id).getIdList(), localID);
		execStmtSeq(funcID.get(id).getStmtSeq());
	}
	
	/**
	 * ID_LIST is a list of identifier(s)
	 * HashMap is for storing value the identifier
	 * */
	public static void execIdList(ID_LIST idList, HashMap<String, Integer> local) {
		String str = idList.getId();

		if(!local.containsKey(str)) {
			local.put(str, null);
		}else {
			System.out.println("Error: duplicate identifier: " + str);
			System.exit(1000);
		}
		if(idList.getNo() == 1) {
			execIdList(idList.getIdList(), local);
		}
	}
	public static void execStmt(STMT stmt) {
		switch(stmt.getNo()) {
			case 1:
				execAssign(stmt.getAssign(), checkIfGlobal(stmt.getAssign().getLvalue()));
				break;
			case 2:
				execIf(stmt.getIf());
				break;
			case 3: 
				execLoop(stmt.getLoop());
				break;
			case 4:
				execIn(stmt.getIn());
				break;
			case 5:
				execOut(stmt.getOut());
				break;
			case 6:
				execFunc(stmt.getFunc());
				break;
			default:
					break;
		}
	}
	public static void execFunc(FUNC func) {
		String str = func.getId();
		ID_LIST idList = func.getIdList();
		execIdList(idList, h);
		hasParam = true;
		execDeclFunc(str);
		
	}
	public static void execAssign(ASSIGN assign, boolean isGlobal) {
		String str = assign.getLvalue();
		if(GLOBALID.containsKey(str) && checkIfGlobal(str)) {
			GLOBALID.put(str, execExpr(assign.getExpr()));
		}else if(localID.containsKey(str)){
			localID.put(str, execExpr(assign.getExpr()));
		}else {
			System.out.println("Error: duplicate identifier: " + str + " found!");
			System.exit(1000);
		}
	}
	public static void execIn(IN in) {
		ID_LIST idList = in.getIdList();
		setByInput(idList);
		//recursively
		while(idList.getNo() == 1) {
			idList = idList.getIdList();
			setByInput(idList);
		}
	}
	public static void execOut(OUT out) { //??? completed?
		//EXPR expr = out.getExpr();
		
		System.out.println(execExpr(out.getExpr()));
	}
	public static void execIf(IF iff) {
		boolean ifCond = execCond(iff.getCond());
		if(ifCond) {
			execStmtSeq(iff.getStmtSeq());
		}else if(iff.getNo() == 1) {
			execStmtSeq(iff.getElseStmtSeq());
		}
	}
	public static void execLoop(LOOP loop) {
		while(execCond(loop.getCond())) {
			execStmtSeq(loop.getStmtSeq());
		}
	}
	public static boolean execCond(COND cond) {
		boolean bool = true;
		switch(cond.getNo()) {
			case 0:	//cmpr
				bool = execCmpr(cond.getCmpr());
				break;
			case 1:	//!cond
				bool = !execCond(cond.getNegCond());
				break;
			case 2:	//cmpr or cond
				bool = execCmpr(cond.getCmpr()) || execCond(cond.getCond());
				break;
			default:
				break;
		}
			
		return bool;
	}
	public static boolean execCmpr(CMPR cmpr) {
		boolean bool = true;
		switch(cmpr.getNo()) {
		case 0:
			bool = execExpr(cmpr.getExpr1()) == execExpr(cmpr.getExpr2());
			break;
		case 1: 
			bool = execExpr(cmpr.getExpr1()) < execExpr(cmpr.getExpr2());
			break;
		case 2:
			bool = execExpr(cmpr.getExpr1()) <= execExpr(cmpr.getExpr2());
			break;
		default: 
			break;
		
		}
		return bool;
	}
	public static int execExpr(EXPR expr) {
		int i = execTerm(expr.getTerm());
		if(expr.getNo() == 1) {
			i = i + execExpr(expr.getExpr());
		}else if(expr.getNo() == 2) {
			i = i - execExpr(expr.getExpr());
		}
		return i;
	}
	public static int execTerm(TERM term) {
		int i = execFactor(term.getFactor());
		if(term.getNo() == 1) {
			i = i * execTerm(term.getTerm());
		}
		return i;
	}
	public static int execFactor(FACTOR factor) {
		int i = 0;
		switch(factor.getNo()) {
		case 0:
			i = factor.getValue();
			break;
		case 1: 
			//i = getValById(factor.getId());
			i = GLOBALID.get(factor.getId());
			break;
		case 2:
			i = execExpr(factor.getExpr());
		}
		return i;
	}
/******************************************************************************/	
	//start reading from data file
	private static void getData(String data) {
		BufferedReader read = null;
		List<String> lines = new LinkedList<String>();
		try {
			read = new BufferedReader(new FileReader(new File(data)));
			String str;
			while ((str = read.readLine()) != null) lines.add(str);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
				if (read != null)
					read.close();
		} catch (IOException ignored) { }
		
		updateDataList(lines);
	}
	
	//split line from DATA file into individual value
	private static void updateDataList(List<String> lines) {
		for (String line : lines) {
			int i = 0, length = line.length();
			while (i < length) {
				String val = "";
				int j = i + 1;
				char first = line.charAt(i);
				if (Character.isDigit(first) || first == '-') {
					while (j < length && Character.isDigit(line.charAt(j))) j++;
					val = line.substring(i, j);
				}
				if (val.length() > 0) {
					try {
						DataFromFile.add(Integer.parseInt(val));
					} catch (NumberFormatException e) {
						System.out.println("Error: " + val + " does not match a valid int");
						System.exit(1000);
					}
				}
				i = j;
			}
		}
	}
	
	//set value of identifier from input for <IN>
	private static void setByInput(ID_LIST idList) {
		if (DataFromFile.size() > 0) {
			String currentId = idList.getId();
			
			if (GLOBALID.containsKey(currentId)) {
				GLOBALID.put(currentId, DataFromFile.remove(0));
			} else {
				System.out.println("ERROR: Identifier " + currentId + " does not exists");
				System.exit(1000);
			}
		} else {
			System.out.println("ERROR: no more input");
			System.exit(1000);
		}
	}
	//get the value of the identifier
	private static int getValById(String id) {
		int result = 0;
		if (GLOBALID.containsKey(id)) {
			if (GLOBALID.get(id) != null) {
				result = GLOBALID.get(id);
			} else {
				System.out.println("ERROR: identifier " + id + " has no value!");
				System.exit(1000); 
			}
		} else {
			System.out.println("ERROR: identifier " + id + " does not exist!!");
			System.exit(1000); 
		}
		return result;
	}
	private static boolean checkIfGlobal(String id) {
		boolean isGlobal = false;
		if(GLOBALID.containsKey(id)) {
			isGlobal = true;
		}
		return isGlobal;
	}
}
